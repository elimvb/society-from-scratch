import json
import random
from utils.text_generation import generate, get_rating, LM_MAX_TOKENS_DICT
import networkx as nx

class Agent:
     
    """
    A class to represent an individual agent in a simulation similar to The Sims.

    Attributes:
    -----------
    name : str
        The name of the agent.
    profession : str
        The profession of the agent.
    personality : str
        The personality of the agent.
    ambitions : str
        The ambitions of the agent.
    personality_MBTI : str
        The MBTI personality type of the agent.
    star_sign : str
        The star sign of the agent.
    income : str
        The income of the agent.
    favorite_pnw_hiking_trail : str
        The favorite Pacific Northwest hiking trail of the agent.
    hobbies : str
        The hobbies of the agent.
    pronouns : str
        The pronouns of the agent.
    location : str
        The current location of the agent in the simulated environment.
    memories : list
        A list of memories the agent has about their interactions.
    compressed_memories : list
        A list of compressed memories that summarize the agent's experiences.

    Methods:
    --------
    
    update_memories(other_agents, global_time, action_results):
        Updates the agent's memories based on their interactions with other agents.
    
    compress_memories(memory_ratings, global_time, MEMORY_LIMIT=10):
        Compresses the agent's memories to a more manageable and relevant set.

    converse(conversation_context, prompt_meta):
        Converse with another agent given the conversation context so far.
    """
     
    def __init__(self, LM, name, description):
        self.LM = LM
        self.name = name
        self.first_name = name.split()[0]
        self.last_name = name.split()[1]
        self.profession = description["profession"]
        self.personality = description["personality"]
        self.ambitions = description["ambitions"]
        self.personality_MBTI = description["personality_MBTI"]
        self.star_sign = description["star_sign"]
        self.income = description["income"]
        self.favorite_pnw_hiking_trail = description["favorite_pnw_hiking_trail"]
        self.hobbies = description["hobbies"]
        self.pronouns = description["pronouns"]
        if "she/" in self.pronouns:
            self.gender = "woman"
            self.opposite_gender = "man"
        elif "he/" in self.pronouns:
            self.gender = "man"
            self.opposite_gender = "woman"
        self.identity_prompt = self.initialize_identity()
        self.memory_ratings = []
        self.memories = []
        self.memory_token_limit = LM_MAX_TOKENS_DICT[self.LM]
        self.compressed_memories = []
        self.memory_log = None

    def __repr__(self):
        return f"Agent({self.name} ({self.pronouns}))"
    
    def initialize_identity(self):
        identity = f'''You are {self.name} ({self.pronouns}). 
        You are {self.profession}. 
        You are {self.personality}. Your MBTI is {self.personality_MBTI}.
        You ambitions are to {self.ambitions}. 
        You star sign is {self.star_sign}. 
        You make {self.income} income. 
        You like to {self.hobbies}. 
        Your favorite Pacific Northwest hiking trail is {self.favorite_pnw_hiking_trail}.'''
        return identity

    def converse(self, incoming_message, partner_name, instructions, max_tokens=512, temperature=0.5):
        """Converse with another agent given the conversation context so far.
        
        Parameters:
        -----------
        incoming_message : str
            The message received from the other agent, e.g. "Hello, how are you?"
        partner_name : str
            The name of the other agent, e.g. "John Smith"
        instructions : str
            The instructions for the agent to follow, e.g. "What do you want to say to [partner_name]? Limit your reponse in x words."
        max_tokens : int
            The maximum number of tokens to generate in the agent's message.
        temperature : float
            The temperature to use when generating the agent's message, where 0 is deterministic and 1 is completely random.
        
        Returns:
        --------
        message : str
            The message generated by the agent.
        n_tokens_used : int
            The total number of tokens used in the agent's entire memory. Should not exceed self.memory_token_limit.
        """
        if partner_name is None or incoming_message is None: # there's no other agent to converse with; just follow the instructions
            new_memory_content = instructions
        else:
            new_memory_content = f'''{partner_name}: "{incoming_message}"\n{instructions}'''

        new_memory = {"role": "user", "content": new_memory_content}

        self.add_to_memory(new_memory)

        message, n_tokens_used = generate(self.LM,
                                          system_prompt=self.identity_prompt,
                                          context=self.memories,
                                          max_tokens=max_tokens,
                                          temperature=temperature,
                                          use_openai=True)

        new_response = {"role": "assistant", "content": message}
        self.add_to_memory(new_response)

        # parse the message to get the content
        if self.first_name in message:
            message_content = message.split(f'{self.first_name}:')[1].strip('" ')
        else:
            message_content = message.strip('" ')

        return message_content, n_tokens_used

    def get_liking_score(self, partner_name):
            """
            Gets the agent's liking score for a given partner.

            Parameters:
            -----------
            partner_name : str
                The name of the partner agent.

            Returns:
            --------
            liking_score : float
                The agent's liking score for the partner.
            """

            prompt = f"Now it's the end of your chat with {partner_name}. How much do you like this person (on a scale of 0 to 100)? Please answer in the format of \"Score: [your_score]\nExplanation: [your_thoughts]\". 50 tokens max."
            message, _ = self.converse(None, None, prompt, max_tokens=50)
            assert "Score: " in message
            liking_score = float(message.split("Score: ")[1].split("\n")[0])
            return liking_score

    def add_to_memory(self, new_memory):

        """
        Adds a new memory to the agent's memories.

        Parameters:
        -----------
        new_memory : dict
            A dictionary containing the new memory, with keys "role" and "content".
        """
        self.memories.append(new_memory)
        self.memory_log.write(new_memory)

    def compress_memories(self, global_time, MEMORY_LIMIT=10):

        """
        Compresses the agent's memories to a more manageable and relevant set.
        
        Parameters:
        -----------
        global_time : int
            The current time in the simulation.
        MEMORY_LIMIT : int, optional
            The maximum number of memories to compress. Default is 10.

        Returns:
        --------
        memory_string : str
            The compressed memory string.
        """

        memories_sorted = sorted(self.memory_ratings, key=lambda x: x[1], reverse=True)
        relevant_memories = memories_sorted[:MEMORY_LIMIT]
        memory_string_to_compress = '.'.join([a[0] for a in relevant_memories])
        return '[Recollection at Time {}:00: {}]'.format(str(global_time), memory_string_to_compress)
    
    def rate_memories(self, locations, global_time, prompt_meta):

        """
         Rates the agent's memories based on their relevance and importance.
        
        Parameters:
        -----------
        locations : Locations
            The Locations object representing different areas in the simulated environment.
        global_time : int
            The current time in the simulation.
        prompt_meta : str
            The prompt used to rate the memories.

        Returns:
        --------
        memory_ratings : list
            A list of tuples representing the memory, its rating, and the generated response.
        """

        memory_ratings = []
        for memory in self.memories:
            prompt = "You are {}. Your plans are: {}. You are currently in {}. It is currently {}:00. You observe the following: {}. Give a rating, between 1 and 5, to how much you care about this.".format(self.name, self.plans, locations.get_location(self.location), str(global_time), memory)
            res = generate(prompt_meta.format(prompt))
            rating = get_rating(res)
            max_attempts = 2
            current_attempt = 0
            while rating is None and current_attempt < max_attempts:
                rating = get_rating(res)
                current_attempt += 1
            if rating is None:
                rating = 0
            memory_ratings.append((memory, rating, res))
        self.memory_ratings = memory_ratings
        return memory_ratings
    
    def move(self, new_location_name):

        if new_location_name == self.location:
            return self.location

        try:
            path = nx.shortest_path(self.world_graph, source=self.location, target=new_location_name)
            self.location = new_location_name
        except nx.NetworkXNoPath:
            print(f"No path found between {self.location} and {new_location_name}")
            return self.location

        return self.location

if __name__ == "__main__":
    config_name = "test"
    config_dir = f'../config/{config_name}'
    agents_config_frn = f"{config_dir}/agents.json"
    LM = "gpt-3.5-turbo-16k"
    with open(agents_config_frn, 'r') as fr:
        town_people = json.load(fr)

    agent_name, agent_description = list(town_people.items())[0]
    agent = Agent(LM, agent_name, agent_description, None)

    incoming_message = "Hello, how are you?"
    partner_name = "Bob"
    instructions = f'''What do you want to say to {partner_name}?
        (Say your part in the format of {agent.first_name}: "[your response]". Don't try to play {partner_name}.)'''
    message, n_tokens_used = agent.converse(incoming_message, partner_name, instructions=instructions)
    print(message, n_tokens_used)